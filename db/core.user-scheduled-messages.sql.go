// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: core.user-scheduled-messages.sql

package db

import (
	"context"

	"github.com/arnokay/arnobot-shared/platform"
	"github.com/google/uuid"
)

const coreUserScheduledMessageCreate = `-- name: CoreUserScheduledMessageCreate :one
INSERT INTO core.user_scheduled_messages (user_id, text, cooldown, platforms)
    VALUES ($1, $2, $3, $4)
RETURNING
    id, user_id, text, cooldown, platforms, created_at, updated_at
`

type CoreUserScheduledMessageCreateParams struct {
	UserID    uuid.UUID
	Text      string
	Cooldown  int64
	Platforms []platform.Platform
}

func (q *Queries) CoreUserScheduledMessageCreate(ctx context.Context, arg CoreUserScheduledMessageCreateParams) (CoreUserScheduledMessage, error) {
	row := q.db.QueryRow(ctx, coreUserScheduledMessageCreate,
		arg.UserID,
		arg.Text,
		arg.Cooldown,
		arg.Platforms,
	)
	var i CoreUserScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Cooldown,
		&i.Platforms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const coreUserScheduledMessageDelete = `-- name: CoreUserScheduledMessageDelete :one
DELETE FROM core.user_scheduled_messages
WHERE id = $1
RETURNING
    id, user_id, text, cooldown, platforms, created_at, updated_at
`

func (q *Queries) CoreUserScheduledMessageDelete(ctx context.Context, id int32) (CoreUserScheduledMessage, error) {
	row := q.db.QueryRow(ctx, coreUserScheduledMessageDelete, id)
	var i CoreUserScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Cooldown,
		&i.Platforms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const coreUserScheduledMessageGetByUserID = `-- name: CoreUserScheduledMessageGetByUserID :many
SELECT
    id, user_id, text, cooldown, platforms, created_at, updated_at
FROM
    core.user_scheduled_messages
WHERE
    user_id = $1
ORDER BY
    updated_at DESC
`

func (q *Queries) CoreUserScheduledMessageGetByUserID(ctx context.Context, userID uuid.UUID) ([]CoreUserScheduledMessage, error) {
	rows, err := q.db.Query(ctx, coreUserScheduledMessageGetByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreUserScheduledMessage
	for rows.Next() {
		var i CoreUserScheduledMessage
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Cooldown,
			&i.Platforms,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const coreUserScheduledMessageGetOne = `-- name: CoreUserScheduledMessageGetOne :one
SELECT
    id, user_id, text, cooldown, platforms, created_at, updated_at
FROM
    core.user_scheduled_messages
WHERE
    id = $1
`

func (q *Queries) CoreUserScheduledMessageGetOne(ctx context.Context, id int32) (CoreUserScheduledMessage, error) {
	row := q.db.QueryRow(ctx, coreUserScheduledMessageGetOne, id)
	var i CoreUserScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Cooldown,
		&i.Platforms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const coreUserScheduledMessageUpdate = `-- name: CoreUserScheduledMessageUpdate :one
UPDATE
    core.user_scheduled_messages
SET
    text = COALESCE($2::text, text),
    cooldown = COALESCE($3::bigint, cooldown),
    platforms = COALESCE($4::public.platform[], platforms)
WHERE
    id = $1
RETURNING
    id, user_id, text, cooldown, platforms, created_at, updated_at
`

type CoreUserScheduledMessageUpdateParams struct {
	ID        int32
	Text      *string
	Cooldown  *int64
	Platforms []platform.Platform
}

func (q *Queries) CoreUserScheduledMessageUpdate(ctx context.Context, arg CoreUserScheduledMessageUpdateParams) (CoreUserScheduledMessage, error) {
	row := q.db.QueryRow(ctx, coreUserScheduledMessageUpdate,
		arg.ID,
		arg.Text,
		arg.Cooldown,
		arg.Platforms,
	)
	var i CoreUserScheduledMessage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Cooldown,
		&i.Platforms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
