// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auth.providers.sql

package db

import (
	"context"
)

const authProviderCreate = `-- name: AuthProviderCreate :one
INSERT INTO auth.providers (
  user_id,
  provider_user_id,
  provider,
  access_token,
  refresh_token,
  access_type,
  scopes
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
) RETURNING id
`

type AuthProviderCreateParams struct {
	UserID         int32    `db:"user_id"`
	ProviderUserID string   `db:"provider_user_id"`
	Provider       string   `db:"provider"`
	AccessToken    string   `db:"access_token"`
	RefreshToken   string   `db:"refresh_token"`
	AccessType     string   `db:"access_type"`
	Scopes         []string `db:"scopes"`
}

func (q *Queries) AuthProviderCreate(ctx context.Context, arg AuthProviderCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, authProviderCreate,
		arg.UserID,
		arg.ProviderUserID,
		arg.Provider,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessType,
		arg.Scopes,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const authProviderGetById = `-- name: AuthProviderGetById :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, access_type, created_at, updated_at, scopes
FROM auth.providers
WHERE id = $1 AND provider = $2
`

type AuthProviderGetByIdParams struct {
	ID       int32  `db:"id"`
	Provider string `db:"provider"`
}

func (q *Queries) AuthProviderGetById(ctx context.Context, arg AuthProviderGetByIdParams) (AuthProvider, error) {
	row := q.db.QueryRow(ctx, authProviderGetById, arg.ID, arg.Provider)
	var i AuthProvider
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scopes,
	)
	return i, err
}

const authProviderGetByProviderUserId = `-- name: AuthProviderGetByProviderUserId :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, access_type, created_at, updated_at, scopes
FROM auth.providers
WHERE provider_user_id = $1 AND provider = $2
`

type AuthProviderGetByProviderUserIdParams struct {
	ProviderUserID string `db:"provider_user_id"`
	Provider       string `db:"provider"`
}

func (q *Queries) AuthProviderGetByProviderUserId(ctx context.Context, arg AuthProviderGetByProviderUserIdParams) (AuthProvider, error) {
	row := q.db.QueryRow(ctx, authProviderGetByProviderUserId, arg.ProviderUserID, arg.Provider)
	var i AuthProvider
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scopes,
	)
	return i, err
}

const authProviderGetByUserId = `-- name: AuthProviderGetByUserId :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, access_type, created_at, updated_at, scopes
FROM auth.providers
WHERE user_id = $1 AND provider = $2
`

type AuthProviderGetByUserIdParams struct {
	UserID   int32  `db:"user_id"`
	Provider string `db:"provider"`
}

func (q *Queries) AuthProviderGetByUserId(ctx context.Context, arg AuthProviderGetByUserIdParams) (AuthProvider, error) {
	row := q.db.QueryRow(ctx, authProviderGetByUserId, arg.UserID, arg.Provider)
	var i AuthProvider
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scopes,
	)
	return i, err
}

const authProviderUpdateTokens = `-- name: AuthProviderUpdateTokens :execrows
UPDATE auth.providers
SET
access_token = COALESCE($1, access_token),
refresh_token = $3,
updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type AuthProviderUpdateTokensParams struct {
	AccessToken  string  `db:"access_token"`
	ID           int32   `db:"id"`
	RefreshToken *string `db:"refresh_token"`
}

// refresh_token = COALESCE($2, refresh_token),
func (q *Queries) AuthProviderUpdateTokens(ctx context.Context, arg AuthProviderUpdateTokensParams) (int64, error) {
	result, err := q.db.Exec(ctx, authProviderUpdateTokens, arg.AccessToken, arg.ID, arg.RefreshToken)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
