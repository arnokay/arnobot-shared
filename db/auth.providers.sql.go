// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auth.providers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const authProviderCreate = `-- name: AuthProviderCreate :one
INSERT INTO auth.providers (
  user_id,
  provider_user_id,
  provider,
  access_token,
  refresh_token,
  access_type,
  scopes
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
) RETURNING id
`

type AuthProviderCreateParams struct {
	UserID         string
	ProviderUserID string
	Provider       string
	AccessToken    string
	RefreshToken   string
	AccessType     string
	Scopes         []string
}

func (q *Queries) AuthProviderCreate(ctx context.Context, arg AuthProviderCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, authProviderCreate,
		arg.UserID,
		arg.ProviderUserID,
		arg.Provider,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessType,
		arg.Scopes,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const authProviderGet = `-- name: AuthProviderGet :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, access_type, scopes, created_at, updated_at
FROM auth.providers
WHERE 
($2::uuid IS NULL OR user_id = $2::uuid) AND
($3::varchar(100) IS NULL OR provider_user_id = $3::varchar(100)) AND
provider = $1
`

type AuthProviderGetParams struct {
	Provider       string
	UserID         pgtype.UUID
	ProviderUserID *string
}

func (q *Queries) AuthProviderGet(ctx context.Context, arg AuthProviderGetParams) (AuthProvider, error) {
	row := q.db.QueryRow(ctx, authProviderGet, arg.Provider, arg.UserID, arg.ProviderUserID)
	var i AuthProvider
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessType,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authProviderGetByProviderUserId = `-- name: AuthProviderGetByProviderUserId :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, access_type, scopes, created_at, updated_at
FROM auth.providers
WHERE provider_user_id = $1 AND provider = $2
`

type AuthProviderGetByProviderUserIdParams struct {
	ProviderUserID string
	Provider       string
}

func (q *Queries) AuthProviderGetByProviderUserId(ctx context.Context, arg AuthProviderGetByProviderUserIdParams) (AuthProvider, error) {
	row := q.db.QueryRow(ctx, authProviderGetByProviderUserId, arg.ProviderUserID, arg.Provider)
	var i AuthProvider
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessType,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authProviderGetByUserId = `-- name: AuthProviderGetByUserId :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, access_type, scopes, created_at, updated_at
FROM auth.providers
WHERE user_id = $1 AND provider = $2
`

type AuthProviderGetByUserIdParams struct {
	UserID   string
	Provider string
}

func (q *Queries) AuthProviderGetByUserId(ctx context.Context, arg AuthProviderGetByUserIdParams) (AuthProvider, error) {
	row := q.db.QueryRow(ctx, authProviderGetByUserId, arg.UserID, arg.Provider)
	var i AuthProvider
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessType,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authProviderUpdateTokens = `-- name: AuthProviderUpdateTokens :execrows
UPDATE auth.providers
SET
access_token = COALESCE($1, access_token),
refresh_token = $3,
updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type AuthProviderUpdateTokensParams struct {
	AccessToken  string
	ID           int32
	RefreshToken *string
}

// refresh_token = COALESCE($2, refresh_token),
func (q *Queries) AuthProviderUpdateTokens(ctx context.Context, arg AuthProviderUpdateTokensParams) (int64, error) {
	result, err := q.db.Exec(ctx, authProviderUpdateTokens, arg.AccessToken, arg.ID, arg.RefreshToken)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
